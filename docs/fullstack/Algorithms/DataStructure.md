# 数据结构总结

算法是用来解决某个问题的。数据结构是算法的实现载体。所以学习数据结构，除了了解常用的基础概念，将不同类型的数据结构解决了什么问题，有什么优势和劣势作为问题方向去进行学习。可惜提高思考效率。

对于数据结构描述语言最好是采用C/C++。不过由于个人的工作语言方向，在这篇笔记里主要采用JS进行实例的编写。如果有其他语言的实现对比需求，推荐可以看一下"hello算法"，关于数据结构具体操作的实例语言更多。

## Docs

- "算法Algorithms(第四版)" 塞奇威克(Sedgewick, R.)(美)韦恩(Wayne, K.)
  > 经典书籍，还有"算法导论"等书籍也是经典书籍。
- [Algorithms, 4th Edition](https://algs4.cs.princeton.edu/home/)
  > 算法(第四版)的配套教育网站
- "大话数据结构" 程杰
  > 适合不了解的人进行学习。但是并不是一本严肃书籍，不适合作为手册深入。推荐有一定基础的学习"算法(第四版)"，更容易养成算法思维。
- [hello算法](https://www.hello-algo.com/)

## 数据结构基础概念

> 这里的概念基础是以计算机行业角度而言，在不同学科里可能同一个名词意义可能有区别。

### 数据

数据是能被计算机识别，并输入给计算机处理的符号集合。

整型、实型等数值类型，还包括字符及声音、图像、视频等非数值类型，都属于数据。

关键点

- 可以输入到计算机中
- 能被计算机程序处理

### 数据对象

数据对象是性质相同的数据元素的集合，是数据的子集。

### 数据元素

数据元素是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。

### 数据项

一个数据元素可以由若干个数据项组成。数据元素的组成单位。

### 数据结构

> 结构是指各个组成部分相互搭配和排列的方式。数据结构就是指数据之间的结构关系。

- 逻辑结构

  > 逻辑结构是指数据对象中数据元素之间的相互关系(理论和逻辑上的)。
  >
  > 逻辑结构分析关键点
  >
  > - 将每一个数据元素看做一个结点，用圆圈表示
  > - 元素之间的逻辑关系用结点之间的连线表示，如果这个关系是有方向的，那么用带箭头的连线表示。
  >
  > 逻辑结构的作用
  >
  > - 逻辑结构是针对具体问题的，是为了解决某个问题，在对问题理解的基础上，选择一个合适的数据结构表示数据元素之间的逻辑关系。

  - 集合结构

    数据元素间关系特点

    - 同属于一个集合
    - 没有关联关系

  - 线性结构

    数据元素间关系特点

    - 一对一的关系

  - 树形结构

    数据元素间关系特点

    - 一对多的层次关系

  - 图形结构

    数据元素间关系特点

    - 多对多的关系

- 物理结构

  > 物理结构是指数据的逻辑结构在计算机中的存储形式

  - 顺序存储结构

    顺序存储结构是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。

    寻找数据元素的方式是通过数据元素在物理上的地址按地址计算方法就能寻找到下一个元素。

  - 链式存储结构

    链式存储结构是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。

    寻找数据元素的方式是通过相关联的数据元素保存的指向该数据元素的指针来找到数据元素。

### 抽象数据类型

- 抽象

  抽象是指抽取出事物具有的普遍性的本质。它是抽出问题的特征而忽略非本质的细节，是对具体事物的一个概括。

  抽象是一种思考问题的方式，它隐藏了繁杂的细节，只保留实现目标所必需的信息。

- 数据类型

  数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。

  常见数据类型分类

  > 以C语言为例

  - 原子类型

    是不可以再分解的基本类型，包括整型、实型、字符型等。

  - 结构类型
    由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数据组成的。

## 算法

### 算法的基本特性(五个)

- 输入
- 输出
- 有穷性
- 确定性
- 可行性

### 算法的设计要求

- 正确性
- 可读性
- 健壮性
- 时间效率高和存储量低

### 算法效率的度量

#### 度量思路

- 时间
  > 一个用高级程序语言编写的程序在计算机上运行时所消耗的时间取决于下列因素。

1. 算法采用的策略、方法。
2. 编译产生的代码质量。
3. 问题的输入规模。
4. 机器执行指令的速度。

- 空间
  > 一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。这些存储就是空间占用。

#### 度量方法

- 事后统计方法
  > 这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。
  - 优点
    - 能够获得一定参数配比以及环境基础上的实际效果。
  - 缺点
    - 需要提前进行实际的程序设计。
    - 需要准备数据，测试数据评估困难。
    - 依赖于实际硬件和软件环境。
- 事前分析估算方法
  > 在计算机程序编制前，依据统计方法对算法进行估算。比如通过算法时间复杂度来估算算法时间效率。

### 算法复杂度

#### 函数特性

- 渐近增长

  给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。

  简而言之，一个函数f(n)，当n在不停变大时，一些f(n)的变化趋势也是有幅度的。幅度越大就代表增长渐近越快。

  所以在这种特性下，我们可以得到这样一个结论，判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项(最高阶项)的阶数。它们是更能体现渐进增长特性的部分。

#### 算法时间复杂度

在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度，也就是算法的时间量度，记作:T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度

所以常用推导大O阶方法O()来体现算法时间复杂度。

##### 大O阶方法

###### 推导大O阶方法思路

1. 用常数1取代运行时间中的所有加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项。
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数。得到的结果就是大O阶。

##### 时间复杂度类型

从算法实际运行的角度来讲，有可能第一个步骤后就得出结果，有可能经历最多的步骤后才得出结果。`一般在没有特殊说明的情况下，都是指最坏时间复杂度`。体现了理论上的可靠性。

- 平均时间复杂度

  平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。也就是说，我们运行一段程序代码时，是希望看到平均运行时间的。可现实中，平均运行时间很难通过分析得到，一般都是通过运行一定数量的实验数据后估算出来的。

- 最坏时间复杂度

  另一种方法是计算最坏情况下的时间复杂度，这种方法称为最坏时间复杂。

##### 常见时间复杂度

!["arithmetic-1"](/img/docs/arithmetic/arithmetic-1.png "arithmetic-1")

#### 算法空间复杂度

一般情况下，一个程序在机器上执行时，除了需要存储程序本身的指令、常数、变量和输入数据外，还需要存储对数据操作的存储单元。

随着问题规规模的增大，占用存储空间占比也呈函数增加，这就是空间复杂度。

算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作:S(n)=O(f(n))，其中，n为问题的规模，f(n)为语句 关于n所占存储空间的函数。

## 物理存储结构

- 物理结构是指数据的逻辑结构在计算机中的存储形式。
- 逻辑结构是面向问题的，而物理结构就是面向计算机的，其基本的目标就是将数据及其逻辑关系存储到计算机的内存中。
- 逻辑结构可以采用不同的物理结构，实现自己的逻辑来处理问题，有不同的优缺点。

### 顺序存储结构

#### 定义

顺序存储结构是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。

#### 优缺点

##### 优点

- 作为`随机存取结构`，可以快速存取任意位置的元素。
- 存储空间进行初始化，不需要额外申请增加存储空间。

##### 缺点

- 删除和插入都需要移动一批元素，相对会更耗时。
- 存储空间进行初始化后，容易出现初始化空间不够用的情况。
- 存储空间进行初始化，容易造成物理存储的碎片化现象。

#### 基本属性

> 顺序存储结构最基本的属性描述。逻辑性的数据结构可以在此基础上进行扩展。

1. 存储空间的起始位置
   > 比如一个数组data，它的存储位置就是存储空间的存储位置。
2. 最大存储容量
   > 初始存储分配长度，数组长度MaxSize。
   >
   > 顺序存储默认是需要进行初始化分配的，存储分配后这个量一般是不变的。部分语言可进行动态分配数组，不过这会带来性能上的损耗。
3. 已使用存储长度
   > 数组的长度length。在任意时刻，已使用存储长度应该小于等于数组的长度。

#### 地址计算方法

存储器中的每个存储单元都有自己的编号，这个编号称为`地址`。

所以在存储起始地址基础上可以计算得到任意位置的地址，并进行存储。它的存取时间性能为O(1)。我们通常把具有这一特点的存储结构称为`随机存取结构`。

#### 常见操作的特点解析

存储数据常见的操作

- `增(插入)`
- `删(删除)`
- `查(查询)`
- `改(修改)`

总结

> 总的来说，在顺序存储结构中判断操作耗时。由于顺序存储的特点，主要有两个思路。
>
> 1. 是否需要移动一批元素`O(n)`
> 2. 是否只查找指定地址元素`O(1)`

##### 增(插入)

1. 移动一批元素腾出空间(`O(n)`)
2. 插入元素(`O(1)`)

插入的时间复杂度为O(n)。

##### 删(删除)

1. 插入元素(`O(1)`)
2. 移动一批元素填充空间(`O(n)`)

删除的时间复杂度为O(n)。

##### 查(查询)

1. 通过地址计算方法找到元素地址(`O(1)`)

查找的时间复杂度为O(1)。

##### 改(修改)

1. 修改元素(`O(1)`)

修改的时间复杂度为O(1)。

### 链式存储结构

#### 定义

链式存储结构是把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的。

#### 优缺点

##### 优点

- 不需要初始化存储空间，可以随时进行申请额外存储空间。
- 删除和插入结点只需要操作指针指向，不需要操作其他不关联的节点。

##### 缺点

- 由于不需要初始化存储空间，额外的存储空间需要临时申请，如果数据较大会增加内存计算负担。
- 查询结点需要使用指针进行迭代查询，耗时相对较多。

#### 基本属性

> 链式存储结构最基本的属性描述。逻辑性的数据结构可以在此基础上进行扩展。

1. `数据域`、`指针域`两部分信息组成数据元素的存储映像，称为`结点`(Node)。
2. 每个结点需要存储数据元素信息(`数据`)的域(`数据域`)。
3. 每个结点需要存储它的直接后继元素的存储地址(`指针`或`链`)的域(`指针域`)。
   > 通过`指针`进行了链式存储结构的串联。可以有多个指针域。
4. 头指针
   > 必须要素。具有标识作用，常以头指针冠名数据结构的名字，指向第一个结点。如果有头结点就指向了头结点。
5. 头结点
   > 非必需元素。头结点是为了方便操作而设置的，使第一结点的插入和删除操作和其他结点相同。数据域一般无意义。
6. 线性链表的最后一个结点指针为“空”(通常用NULL或“^”符号表示)

#### 常见操作的特点解析

存储数据常见的操作

- `增(插入)`
- `删(删除)`
- `查(查询)`
- `改(修改)`

总结

> 总的来说，在链式存储结构中判断操作耗时。由于链式存储的特点，主要有两个思路。
>
> 1. 是否需要`工作指针后移`查找结点`O(n)`
> 2. 是否只需要多个结点间的指针域存储信息进行变化，实现所指向的结点地址更新`O(1)`

##### 增(插入)

1. 前继结点和当前结点指针域变化，新增结点(`O(1)`)

插入的时间复杂度为O(1)。

##### 删(删除)

1. 前继结点指针域变化，删除结点(`O(1)`)

删除的时间复杂度为O(1)。

##### 查(查询)

1. `工作指针后移`查找结点(`O(n)`)

查找的时间复杂度为O(n)。

##### 改(修改)

1. 当前结点数据域变化，修改结点数据信息(`O(1)`)

修改的时间复杂度为O(1)。

## 数据结构

> 总结常见的数据结构、其常用操作的算法思路、以及应用。

逻辑结构可分为“线性”和“非线性”两大类。线性结构比较直观，指数据在逻辑关系上呈线性排列；非线性结构则相反，呈非线性排列。

- 线性数据结构：数组、链表、栈、队列、哈希表
- 非线性数据结构：树、堆、图、哈希表

数据结构常用操作补充约定

1. 数组下标默认从0开始。
2. 基本操作中提到的操作位置默认从1开始。
3. 操作方法通用返回值，操作成功返回1(success)，操作失败返回0(error)

### 线性表

线性表(List): 零个或多个数据元素的`有限``序列`。

#### 数组

> 线性表顺序存储结构。基本特点最类似顺序存储结构的数据结构，可以以此参考分析顺序存储结构的一些本质特点。

##### 数组基本属性

- data 数据
- maxSize 已分配最大长度
- length 已使用最大长度

##### 数组常用操作

###### 初始化

> 其实JS中Array就是与数组类似的数据类型，不过为了学习数据结构基本的处理，进行一层包装。

思路

1. 创建类
2. 定义基本属性
3. 构造实例时传入需要预定义的参数
   - 分配最大长度maxSize

```typescript
class ArrayList {
  data: any; // 数据
  maxSize: number; // 已分配最大长度
  length: number; // 已使用最大长度
  constructor(maxSize: number) {
    this.data = new Array(maxSize);
    this.maxSize = maxSize;
    this.length = 0;
  }
}

let array = new ArrayList(20);
console.log(array); // ArrayList { data: [ <20 empty items> ], maxSize: 20, length: 0 }
```

###### 插入

算法思路

1. 数组是否还能插入
   - 判断数组是否已满，`length == maxSize` 。如果数组长度大于等于数组长度，则抛出异常或动态增加容量。
2. 插入位置判断是否合理
   - 插入数据位置是否符合要求(大于等于1、并且小于等于"已使用最大长度 + 1") `i < 1 || i > length + 1`。
     > 已使用最大长度 + 1 就是尾部的位置
   - 如果插入位置不合理，抛出异常。
3. 进行插入操作
   - 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置。
   - 如果确认直接插入最后一位，那么不需要进行遍历移动。插入位置是否不在尾部 `i <= length`
   - 最后数组长度加一。

```typescript
function insert(arrayList: ArrayList, index: number, item: any): number {
  if (arrayList.length == arrayList.maxSize) {
    return 0;
  }

  if (index < 1 || index > arrayList.length + 1) {
    return 0;
  }

  if (index <= arrayList.length) {
    for (let i = arrayList.length - 1; i >= index - 1; i--) {
      arrayList.data[i + 1] = arrayList.data[i];
    }
  }

  arrayList.data[index - 1] = item;
  arrayList.length++;

  return 1;
}

console.log(insert(arrayList, 1, 1)); // 1;
console.log(arrayList); // ArrayList { data: [ 1, <19 empty items> ], maxSize: 20, length: 1 }
```

###### 删除

算法思路

1. 删除位置判断是否合理
2. 进行删除操作
   - 删除当前位置元素
   - 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置
   - 最后数组长度减一。

```typescript
function remove(arrayList: ArrayList, index: number): number {
  if (index < 1 || index > arrayList.length + 1) {
    return 0;
  }

  // empty index data
  arrayList.data[index - 1] = null;
  if (index < arrayList.length) {
    for (let i = index - 1; i < arrayList.length; i++) {
      arrayList.data[i] = arrayList.data[i + 1];
    }
  }
  arrayList.length--;

  return 1;
}
console.log(insert(arrayList, 1, 1)); // 1;
console.log(arrayList); // ArrayList { data: [ 1, <19 empty items> ], maxSize: 20, length: 1 }
console.log(remove(arrayList, 1)); // 1
console.log(arrayList); // ArrayList { data: [ null, <19 empty items> ], maxSize: 20, length: 0 }
```

###### 查询

算法思路

1. 查询位置判断是否合理
2. 进行查询操作

```typescript
function find(arrayList: ArrayList, index: number): number {
  if (index < 1 || index > arrayList.length + 1) {
    return 0;
  }
  return arrayList.data[index - 1];
}
console.log(insert(arrayList, 1, 1)); // 1;
console.log(arrayList); // ArrayList { data: [ 1, <19 empty items> ], maxSize: 20, length: 1 }
console.log(find(arrayList, 1)); // 1
```

###### 修改

算法思路

1. 修改位置判断是否合理
2. 进行修改操作

```typescript
function update(arrayList: ArrayList, index: number, item: any): number {
  if (index < 1 || index > arrayList.length + 1) {
    return 0;
  }
  arrayList.data[index - 1] = item;
  return 1;
}
console.log(insert(arrayList, 1, 1)); // 1;
console.log(arrayList); // ArrayList { data: [ 1, <19 empty items> ], maxSize: 20, length: 1 }
console.log(update(arrayList, 1, "update")); // 1
console.log(arrayList); // ArrayList { data: [ 'update', <19 empty items> ], maxSize: 20, length: 1 }
```

#### 单链表

> 线性表链式存储结构。基本特点最类似链式存储结构的数据结构，可以以此参考分析链表存储结构的一些本质特点。

##### 单链表基本属性

一个单链表中包含多个结点。链表本身就是一个`头指针`具有标识作用。通常是采用含`头结点`的方式进行链表的创建，可以存储额外链表信息。

在JS实现过程中，链表指向的实际就是一个结点。所以采用继承结点的方式通过TS的类型检查。

```typescript
class LinkedList extends LinkedListNode {}
```

##### 单链表结点基本属性

- 数据域
- 指针域
  - 直接后继指针

```typescript
class LinkedListNode {
  data: any; // 数据域
  next: LinkedListNode; // 指针域 - 直接后继指针
  constructor() {
    this.data = null;
    this.next = null;
  }
}
```

##### 单链表常用操作

链表常用操作补充

- 指针
  > 在JS语义中可以认为简单就是一个引用对象，作用类似。C/C++语言中，指针存放的是地址，指向的是地址对应存储的数据。

###### 初始化(整表创建)

创建单链表的过程就是一个动态生成链表的过程。即从“空表”的初始状态起，依次建立各元素结点，并逐个插入链表。另外创建链表的方式不一样也会影响到其他的操作方法。

整表创建方法

> 根据新结点的插入位置不同，有不同的操作方式。主要的区别有两点: 1. 插入之后的结点顺序(习惯上应该是新数据在尾部，最后读取)、2. 是否需要遍历旧链表(会增加耗时)。

- 头插法
  > 头插就是将新元素插在链表头部
  >
  > 特点
  >
  > - 插入速度快（不需要遍历旧链表）
  > - 头结点每次插入都会变化，头结点永远是最新的元素
  > - 遍历时是按照插入相反的顺序进行
  > - 由于头结点不断在变化，所以需要额外的维护头结点的引用

算法思路

1. 声明临时指针p
   > p用于新结点副本
2. 初始化一空链表l
   > 在C/C++中需要进行内存空间的初始化申请。JS里面不需要，直接在外层声明实例后作为参数传入。在JS方式下，将结点和链表做了继承关系，使用多态的特点(面向对象的三个基本特征是：封装、继承、多态)。
3. 让L的头结点的指针指向null，即建立一个带头结点的单链表
4. 循环(传入参数n，创建n个结点的链表)
   - 生成新结点并赋值给p;
   - 初始化新结点数据域
   - 将p插入到头结点与前一新结点之间
     > 交换指针，其实在JS可以看成引用值交换，最终目的是将新结点插入到头结点和原第二结点之间
     >
     > 1. p = 新结点;
     > 2. p的next指针与l的next指针进行交换;
     > 3. l的next指向p;

```typescript
function createLinkedList(l: LinkedListNode, n: number): number {
  let p = new LinkedListNode();
  l.next = null;

  for (let i = 0; i < n; i++) {
    p = new LinkedListNode();
    p.data = i;
    p.next = l.next;
    l.next = p;
  }

  return 1;
}

let l = new LinkedList();
createLinkedList(l, 2);
console.log(l);

// output:
// LinkedList {
//   data: null,
//   next: LinkedListNode {
//     data: 1,
//     next: LinkedListNode { data: 0, next: null }
//   }
// }
```

- 尾插法
  > 尾插就是将新元素插在链表尾部
  >
  > 特点
  >
  > - 插入速度慢（需要遍历旧链表到最后一个元素）
  > - 头结点永远固定不变
  > - 遍历时是按照插入相同的顺序进行
  >   算法思路

1. 声明临时指针p，r
   > p用于新结点副本。r用于表示当前操作结点，后续会不断变更r，作为新结点衔接的直接旧结点`表尾终端结点`。
2. 初始化一空链表l
   > 在C/C++中需要进行内存空间的初始化申请。JS里面不需要，直接在外层声明实例后作为参数传入。在JS方式下，将结点和链表做了继承关系，使用多态的特点(面向对象的三个基本特征是：封装、继承、多态)。
3. 让L的头结点的指针指向null，即建立一个带头结点的单链表
4. r复制l的引用关系指向l的数据。
5. 循环(传入参数n，创建n个结点的链表)
   - 生成新结点并赋值给p;
   - 初始化新结点数据域
   - 表尾终端结点的直接后继指针指向新结点，并变换表尾终端结点为新结点
     > 1. r.next = p; r的引用地址实际是l的引用地址，所以这里修改r.next，实际上修改的是l.next
     > 2. r = p; r与p进行交换，只是表示当前的最新结点是上一次创建的p结点。并没有修改l结点。
6. 最后一个结点直接后继指针指向null

```typescript
function createLinkedList(l: LinkedListNode, n: number): number {
  let p = new LinkedListNode();
  let r = new LinkedListNode();
  l.next = null;

  r = l;

  for (let i = 0; i < n; i++) {
    p = new LinkedListNode();
    p.data = i;
    r.next = p; // r的引用地址实际是l的引用地址，所以这里修改r.next，实际上修改的是l.next
    r = p; // r与p进行交换，只是表示当前的最新结点是上一次创建的p结点。并没有修改l结点。
  }
  r.next = null;

  return 1;
}

let l = new LinkedList();
createLinkedList(l, 3);
console.log(l); // LinkedListNode {"data":null,"next":{"data":0,"next":{"data":1,"next":{"data":2,"next":null}}}}
```

###### 整表删除

在C/C++语言中，可以主动对数据进行内存释放。整表删除就是释放链表所占用的内存。基本方式就是遍历链表进行不断的释放结点。

算法思路

1. 声明临时指针p和临时指针q;
   > p作为当前释放结点引用副本、q作为下一个即将释放的结点的引用副本。
2. 将第一个结点赋值给p
3. 循环:
   - 将下一结点赋值给q
   - 释放p
   - 将q赋值给p，继续循环
4. 最后将头指针置null

###### 插入

主要使用在头插法中的结点新增逻辑。在结点间插入一个新结点。

核心步骤

> 顺序不可乱，一定是先让新结点增加对旧结点的引用，然后其他旧结点才切换引用关系到新结点。否则先引用新结点，那么之前的旧结点就断开没地方保存了。

- s = new Node;
  > s是一个新结点
- s.next = p.next;
  > p的next引用指向了一个后继结点。新结点s复制了引用，所以s也指向了这个后继结点(假设i)。
- p.next = s;
  > 然后p的next引用换成了结点s，表示s作为了它的新的后继结点。那么p、s、i依旧保存了链式的引用关系。

###### 删除

删除结点和插入结点有相似之处，不过是修改要删除结点的直接前继结点的next引用关系，让前继结点的next引用该结点的直接后继结点。

核心步骤

> 修改要删除结点的直接前继结点的next引用关系，让前继结点的next引用该结点的直接后继结点。

- q = p.next;
  > 这个不是具体步骤，只是一个引用关系。核心步骤是下面一步，将要删除的结点q替换后就能得到综合步骤p->next=p->next->next;
- p.next = q.next;
  > 让要删除的结点q的前继结点p的next引用指向q
- 综合: p->next=p->next->next

###### 查询

核心的思路就是不断迭代链表中的结点，当符合查找要求时把结点数据保存。而迭代的方式通常是采用一个临时的结点保存链表结点的引用，并不断访问next的方式迭代下一个结点。

核心步骤

- p = p.next
  > p的next引用是下一个结点，这里就是将下一个结点的引用覆盖给了p

算法思路

1. 声明一个指针p指向链表第一个结点，初始化位置标识j从1开始;
2. 当j < i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1;
3. 若到链表末尾p为空，则说明第i个结点不存在;
4. 否则查找成功，返回结点p的数据。

```typescript
function find(l: LinkedListNode, i: number, result: any) {
  let p = new LinkedListNode();
  p = l.next;
  let j = 1;
  if (i < 1) {
    return 0;
  }

  while (p && j < i) {
    d;
    p = p.next;
    j++;
  }

  if (!p || j > i) {
    return 0;
  }

  result.data = p.data;
  return 1;
}

let result = { data: "" };
console.log(find(l, 2, result)); // 1
console.log(result); // { data: 1 }
```

#### 静态链表

使用数组的方式来描述的链表被称为静态链表。这种实现方法也叫游标实现法。

##### 优缺点

- 优点
  - 解决了顺序存储结构下，移动和删除元素需要移动一批元素的缺点。
- 缺点
  - 没有解决顺序存储分配带来的表长难确定问题
  - 失去了顺序存储结构的随机存取特性

##### 特点总结

- 没有指针域，只有两个数据域
  - 数据域data: 结点数据
  - 数据域cur: 替代指针域，保存的是直接后继结点的数组下标。如果是已使用链表的最后一个结点，cur为0，0坐标存放了备用链表第一个结点下标。
- 对数组第一个和最后一个元素作为特殊元素处理，不存数据
  > - 通常把未被使用的数组元素称为备用链表
  - 数组第一个元素，下标为0的元素的cur就存放备用链表的第一个结点的下标。
  - 数组的最后一个元素，它的cur则存放第一个有数值的元素的下标。相当于单链表中的头结点作用，当整个链表为空时，则为0。

##### 常用操作

静态链表和单链表在操作上相比，主要的区别是静态链表需要主动去管理结点申请、释放，处理保存一些信息。而单链表申请(malloc())、释放(free())结点都是直接提供了对应的方法。其他的操作逻辑，两者核心都是一致的，交换引用关系(指针域/数据域cur)。

静态链表管理结点申请、释放逻辑

- 申请结点

1. 把第一个元素保存备用链表第一个结点下标，获取该下标作为新结点的下标。
2. 将位于该下标的备用结点的数据域cur复制给数组第一个元素的数据域cur。表示备用链表减一。

- 释放结点

1. 把第一个元素的数据域cur值赋给要删除的元素的数据域cur。表示将该元素作为到备用链表第一个结点的前一个结点，最后在第二步之后实现了结点在备用链表的插入。
2. 把要删除的元素下标赋值给第一个元素的数据域cur。表示备用链表加一。

###### 初始化

```typescript
class StaticLinkedListNode {
  data: any; // 数据域
  cur: StaticLinkedListNode; // 数据域
  constructor() {
    this.data = null;
    this.cur = null;
  }
}
```

#### 循环链表

将单链表中终端结点(最后一个结点)的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表(circular linked list)。

##### 特点总结

- 对终端结点的指针域进行了处理。将单链表中终端结点(最后一个结点)的指针端由空指针改为指向头结点。实现链表的成为了环的效果。
- 循环链表和单链表的主要差异就在于循环的判断条件上，原来是判断p->next是否为空，现在则是p->next不等于头结点，则循环未结束。

#### 双向链表

双向链表(double linkedlist)是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。

##### 特点总结

- 双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。可以实现两个方向的遍历。
- 在实际操作中，还是在单向的遍历基础上进行增加删除，但是需要额外处理双向指针域的关联。之前单链表只需要处理一个方向的指针域关系。

##### 常用操作

###### 初始化

```typescript
class LinkedListNode {
  data: any; // 数据域
  next: LinkedListNode; // 指针域 - 直接后继指针
  prior: LinkedListNode; // 指针域 - 直接前驱指针
  constructor() {
    this.data = null;
    this.next = null;
    this.prior = null;
  }
}
```

### 栈

栈是限定仅在表尾进行插入和删除操作的线性表。由于其结构特性，栈又称为后进先出(LastIn First Out)的线性表，简称LIFO结构。

#### 特点总结

- 基本组成: 栈顶、栈底
  - 栈顶(top)
    > 允许插入和删除的一端。插入数据的过程称为`进栈`或`压栈(push)`，删除数据的过程称为`出栈`或`弹栈(pop)`，访问栈顶元素是`peek()`。
  - 栈底(bottom)
    > 不允许插入和删除的一端。
  - 空栈
    > 不含任何数据元素的栈
- 后进先出(LastIn First Out)特性
  后插入的元素在读取栈数据的时候被先取出来。
- 栈在顺序存储结构和链式存储结构下的区别
  - 顺序存储结构可以倚靠地址寻址规则直接查找对应地址，结点不需要存储额外的下标。
  - 链式存储结构中的结点需要保存下一个结点的指向地址，以供迭代。栈的名称本质只是一个头指针。

#### 基本属性

- 栈和栈元素的基本属性(顺序存储结构)
  - 栈
    - 数组data
    - 栈顶的数组下标
  - 栈结点
    - 数据域

```typescript
// 栈结点
class StackNode {
  data: any; // 结点数据域
  constructor() {
    this.data = null;
  }
}

// 栈
class Stack {
  data: Array<any>;
  top: StackNode; // 栈顶下标
  constructor() {
    this.top = null;
  }
}
```

- 栈和栈元素的基本属性(链式存储结构)
  - 栈
    - 栈顶指针top
  - 栈结点
    - 数据域
    - 指针域 - next指针

```typescript
// 栈结点
class StackNode {
  data: any; // 结点数据域
  next: StackNode; // 结点next指针
  constructor() {
    this.data = null;
    this.next = null;
  }
}

// 栈
class Stack {
  top: StackNode; // 栈顶指针
  constructor() {
    this.top = null;
  }
}
```

#### 常用操作

##### 初始化

栈的实现方式有两种，顺序存储结构和链式存储结构。都采用头插法的方式进行新结点的插入。

- 顺序存储结构

```typescript

```

- 链式存储结构

```typescript

```

##### 增加(进栈)

##### 删除(出栈)

### 队列

TODO

### 串

TODO

### 树

TODO

### 图

TODO

## 数据结构应用

> 以实际应用角度出发，总结实际的算法和采用的数据结构。

### 查找

TODO

### 排序

TODO
