# 面试突击计划

## DOCS

- [一天突击大厂React常见前端面试题(bilibili)](https://www.bilibili.com/video/BV1y94y1v7TL/?spm_id_from=333.337.search-card.all.click&vd_source=df7c2cd1afdc7ae35be0af6c0c76be67)

- [前端已死？前端面试、前端面试题、前端面试实录、前端面试准备(bilibili)](https://www.bilibili.com/video/BV1Th411G7iN?p=5&vd_source=df7c2cd1afdc7ae35be0af6c0c76be67)
  
  > 感觉面试人员似乎是统一培训的，技术栈单一。几个面试内容主要是vue技术栈，都是比较基础的题。

- [日问(github))](https://github.com/shfshanyue/blog/tree/master/op)
  
  > 程序员山月的前端面试题文档集

- [q.shanyue.tech(博客)](https://q.shanyue.tech/)
  
  > 程序员山月的面试问题整理集合博客

- [大三字节实习生同学面试实录，预测毕业25k大厂起步，有关 React 与前端工程化](https://www.bilibili.com/video/BV1XF411E74j/?spm_id_from=333.337.search-card.all.click&vd_source=df7c2cd1afdc7ae35be0af6c0c76be67)
  
  > 程序员山月的面试实录很多，有参考意义。这个内容在部分知识点比较深，但是在单一领域不广。

- [两年前端经验简历点评与面试实录，这水平来年可否战大厂？！](https://www.bilibili.com/video/BV1V34y1B7Br/?spm_id_from=333.788&vd_source=df7c2cd1afdc7ae35be0af6c0c76be67)
  
  > 和我的经验程度比较像，参考。

- [前端一年工作经验面试实录，沈阳求职，一年经验基础要牢要牢，面试要多！](https://www.bilibili.com/video/BV1Pa411m7qr/?spm_id_from=333.788&vd_source=df7c2cd1afdc7ae35be0af6c0c76be67)
  
  > 我的半吊子和这个很像

- [一年半前端经验，坐标广州，16k 面试实录，有关首屏的极致优化与 http 基础等](https://www.bilibili.com/video/BV1hm4y1Z7R5/?spm_id_from=333.788&vd_source=df7c2cd1afdc7ae35be0af6c0c76be67)
  
  > 比我强一些，但是各个知识点都是浅入

- [厦门前端一年半经验13K面试实录，关于 ES6+ 及 Webpack 提问，及厦门有哪些著名互联网公司](https://www.bilibili.com/video/BV1L34y1C7hZ/?spm_id_from=333.788&vd_source=df7c2cd1afdc7ae35be0af6c0c76be67)
  
  > 偏JS基础，感觉自己基础还不如这位面试者。

- [两年前端，广州求职，要价 14k，依我说，小伙子可以多要点，涉及组件建设、工程化以及丰富的项目](https://www.bilibili.com/video/BV1QZ4y1h78T/?spm_id_from=333.788&vd_source=df7c2cd1afdc7ae35be0af6c0c76be67)
  
  > 

- [如果我是初级前端工程师，碰到这些面试题我会怎么回答？](https://www.bilibili.com/video/BV1XL411c7vU/?spm_id_from=333.788&vd_source=df7c2cd1afdc7ae35be0af6c0c76be67)
  
  > 林三心的挖掘机，面试笔记重点(初期)

- [前端面试：两年前端经验，我问的很难吗？Vue、TypeScript、前端工程化、ES6+、源码](https://www.bilibili.com/video/BV1aX4y1L7Yf/?spm_id_from=333.788&vd_source=df7c2cd1afdc7ae35be0af6c0c76be67)
  
  > 比较接近我现在的层级的问题。问的不难，但是没背好题

- [2年前端(外包经历) 6月部分面试记录 （高级、资深岗位）(知乎)](https://zhuanlan.zhihu.com/p/448600149?utm_id=0)
  
  > 面经，外包出身，和自身经历类似可参考。

- [三年前端，面试思考（头条蚂蚁美团offer）(掘金)](三年前端，面试思考（头条蚂蚁美团offer）)
  
  > 大佬的面经，学习奋斗努力的经验

- [2年前端暑期面试打怪升级（收获多份offer）(掘金)](https://juejin.cn/post/6876327630212169735)
  
  > 大佬前端面经

- [ES6及ESNext规范详解(掘金)](https://juejin.cn/post/7067840528246636575#heading-21)
  
  > ES6高频知识点

- [JavaScript Guidebook(github)](https://tsejx.github.io/javascript-guidebook/core-modules/executable-code-and-execution-contexts/concurrency-model/event-loop/)
  
  > 优质博客

## 刷B站实战并总结[15:30 - 16:40] - [延期 17:30] - [延期 19:00 - 20:00] - [延期 20:00 - 21:00] - [延期 23:00 - 1:00] - [延期 1:00 - 2:00] - [延期 2:00 - 3:00] - [延期 8:00 - 10:00]

基本流程

1. 主要技术栈基础面试题
2. 次要技术栈基础面试题
3. 项目技术
   1. 针对项目中实现的内容进行提问
4. 项目经验
   1. 开发流程
   2. 人员配比
   3. 人天需求分析
   4. 代码管理，CodeReview流程

经验体会

1. 通过基础分析开发技术能力
2. 通过项目知识分析开发的业务能力
3. 在回答项目管理相关的问题，要尽量符合规范的流程。
4. 回答的时候，对于基础知识点，先技术方面进行思考，然后是运维维护，最后是业务实现来思考。
5. 提问的内容是根据简历来的。简历上写的内容需要准备一套备用话术。

自我介绍话术

1. 自己背景
2. 结合岗位要求讲解自己的优势
3. 引导项目经验

老师好，我是面试者张瑶，目前从事前端开发已经两年多，从实习至今一直供职于长亮。
技术栈主要是前端技术栈包括React、Vue。也使用过公司内部的混合式APP框架Tinybuilder进行客户端的开发。熟悉一些基本的Nginx代理配置和Docker容器使用知识。
经历过多个项目，有良好的开发习惯和业务开发思维，能够较快的上手理解业务和执行开发任务。

项目问题

- 安徽农村信用社联合社金农易贷管理系统
  
  > 简历给自己挖坑，写不知道咋做的事情。
  
  - useEffect自定义React Hooks来解决页面刷新(缓存数据加载)
    
    > 解决页面刷新次数登记的问题，自定义Hook，通过localStorage来取出缓存的数据，比如刷新次数。
  
  - useEffect自定义React Hooks来处理异步请求处理
    
    > axios封装网络请求，然后自定义Hook，通过useEffect再封装一层支持参数的传输和redux控制loading的加载以及处理error的抛出。
  
  - 函数式组件的封装技巧
    
    > from chatgpt
    >   使用 Props：合理使用组件的 props，将组件的行为和外部数据进行解耦。通过传递不同的 props 值，使组件能够适应各种情况下的展示和功能需求。
    
      使用默认值和类型检查：为组件的 props 设置默认值，以防止因缺少某些 props 而导致的错误。同时，可以使用 PropTypes 或 TypeScript 等工具对组件的 props 进行类型检查，确保正确使用和传递 props。
    
    > class components: propTypes进行类型检查，defaultProps设置默认值
    > 
    > function components: 而函数式组件只能通过显式的判断和默认值给予。
    >   提取可复用的逻辑：如果存在可复用的逻辑或功能，可以将其提取为自定义的 Hooks 或辅助函数，以便在多个组件中共享和重复使用。
    
      使用组合和高阶组件：利用组合和高阶组件的概念，可以将多个小型组件组合起来形成更大的组件，实现组件的复用和灵活性。
    
      单一职责原则：确保每个组件只关注单一的职责或功能。通过将组件拆分为更小的组件，可以提高组件的可维护性和复用性，并使代码更易于理解和测试。
    
      避免状态共享：尽量避免在多个组件之间共享状态。如果需要共享状态，可以考虑使用状态管理库（如 Redux、MobX）来管理该状态，而不是将其存储在组件层级中。
    
      使用 Render Props 或 Hooks：使用 Render Props 或自定义 Hooks，可以将组件的复用逻辑以可配置的方式传递给其他组件，从而实现更高级的组件封装和代码重用。
    
      模块化组织：根据项目的需求和结构，合理地组织和划分组件，使得整个代码库具有清晰的结构，易于维护和扩展。
    
      总的来说，函数式组件的封装技巧包括合理使用 props、提取可复用的逻辑、使用组合和高阶组件、遵循单一职责原则等。这些技巧能够帮助改善代码的可读性、可维护性和可重用性，提高开发效率。
  
  - sass和less

- 邮惠万家银行2022年新增功能工程(三期)

- 海外国际菲律宾CIMB互联网产品前端数据迁移项目
  
  - Spring @Async和输出csv 逗号格式

- Sinarmas手机银行-群组账户专项
  
  - TinyBuilder
    
    > - [跨平台布局引擎Yoga的学习和使用(博客)](https://juejin.cn/post/6844903591233191943)
  
  - 小程序
    
    > - [前端面试题之——小程序篇(博客)](https://www.rstk.cn/news/614260.html?action=onClick)
  
  - Less和Sass
    
    > - [【查缺补漏】css、Less、Sass定义变量，混合，嵌套，运算等（内含10道面试题）(博客)](https://blog.csdn.net/qq_37210523/article/details/110412583)

高频面试题

- 图片懒加载

- React: 缓存 reactMemo/useCallback

- http缓存

- 跨域

- 简单请求/复杂请求

- webpack

- vite

- commonjs

- ES Module

- vue的数据响应式原理
  
  > vue2和vue3的区别

- 路由懒加载

- 防抖和节流

- HTTP1、HTTP2、HTTP3

- 小程序原生

- 补充
1. JS Number范围 正负2的53次方

2. HTTP状态码
   
   > - [HTTP 中常用的状态码（14种）(解决)](https://juejin.cn/post/6844904202863394830)
   >   200
   >   301
   >   302
   >   304
   >   400
   >   401
   >   403
   >   404
   >   500
   >   502
   >   503
   >   504

3. apply、call 、bind作用和区别
   
   > - [apply、call 、bind作用和区别](https://juejin.cn/post/6844903866358562824)

4. ES6

5. CSS3
- [开始学习CSS3(W3cSchool)](https://www.w3cschool.cn/css3/htkn4flf.html)
6. HTML5
- [HTML5 教程(W3cSchool)](https://www.w3cschool.cn/html5/)

押面试题

- JS
  - 原型和原型链
  - this指向
  - apply、call 、bind作用和区别
  - ES6特性(常用)
    - let 和 const：用于定义块作用域变量。
    - 箭头函数：使用箭头（=>）符号定义函数，具有更简洁的语法和更短的代码长度。
    - 模板字符串：使用反引号（`）定义字符串，支持嵌入表达式、模板标签、多行字符串等。
    - 解构赋值：将数组或对象的值赋给变量的过程变得更加简洁。
    - Class：支持基于类的面向对象编程方式。
    - Promise：提供了更好的异步处理方式，可以实现更加灵活的编程。
    - 模块化：提供了更好的模块化机制，支持 ES6 模块的导入和导出。
- Vue
- React
  - 常用Hook
- 性能优化
- 前端工程化(Weboack)
- 浏览器部分
- 计算机网络
- HTML
  - HTML5特性(常用)
    - Web 存储：Local Storage 和 Session Storage 可以让 Web 应用在本地存储数据，在离线状态下也能访问到数据。
    - Canvas：HTML5 提供了 Canvas 标签来用于绘制图形和创建动画。
    - Web 音频和视频：支持在 Web 应用程序中嵌入音频和视频。
    - Geolocation：可以获取用户的位置。
    - Web Workers：在后台运行的脚本，可以加速应用程序的性能。
    - Web Socket：以全双工、实时、带原生二进制数据的方式进行网络通信。
- CSS
  - CSS3特性(常用)
    - 选择器：增加了更多的选择器，比如属性选择器、伪类选择器等。
    - 盒模型：增加了盒子的重叠、对齐、增加圆角等新特性。
    - 文本和字体：增加了文本阴影、字体嵌入、多列布局等新特性。
    - 背景和边框：增加了多重背景、渐变背景、背景尺寸等新特性。
    - 动画和变形：增加了动画、过渡、旋转、缩放、倾斜、平移等新特性。
- 补充
  - 状态码

二面面试题(高频)
参考这份文档

- [2年前端暑期面试打怪升级（收获多份offer）(掘金)](https://juejin.cn/post/6876327630212169735)
  
  > 大佬前端面经

个人评价
基础不牢，没有技术侧重点。
项目问答准备薄弱。

改进方向

1. 夯实基础 - 框架React、JS原生
2. 确定技术侧重点 - 性能优化

## 刷B站面试题并总结[16:40- 17:30] - [延期 18:00 - 19:00]

> 和(刷B站实战并总结)合并。

## 整理基础面试资料和常见面试题[17:50 - 19:00] - [ 未执行]

## 整理面试脉络框架[19:00 - 19:40] - [ 未执行 ]

## 模拟面试[19:40 - 20:30] - [ 未执行 ]

## 面试总结-0920-招行外包-杭州-一轮

### 面试前准备

1. 知识点总结
2. 面试实录参考总结
3. 再总结高频面试题
4. 整理项目可问知识点，作为高频面试点。
5. 合适的休息，睡觉 22:00 - 23:00，刷题 23:00 - 03:00，睡觉 03:00 - 07:30，刷题 08:00 - 10:00
6. 期间强制不允许刷短视频，看短剧，看小说这类容易沉浸而且无用的内容。会分散注意力，而且不利于状态的维护。这是场持久战。

### 面试前两个小时状态

1. 把高频面试题中的高频、项目面试题再过一遍
2. 自己对自己进行完成的模拟面试三次
3. 最后20分钟什么也不做，保持冥想放空状态
4. 提前20分钟进入会议，熟悉会议环境，模拟面试一次找到感觉。

### 面试现场

- 面试官确认是否是当前面试者
  
  > 是

- 面试官要求自我介绍
  
  > 老师好，我是面试者张瑶，目前从事前端开发已经两年多，从实习至今一直供职于长亮。
  > 技术栈主要是前端技术栈包括React、Vue。也使用过公司内部的混合式APP框架Tinybuilder进行客户端的开发。

- 面试官提问：目前项目情况，开发人员情况
  
  > 回答：已经上线，H5端之后两个开发人员，主系统十个开发人员

- 面试官提问：在项目的负责内容以及技术栈
  
  > 回答：负责渠道端H5的前端开发，以及部署处理，以React作为技术栈。

- 面试官提问：JS的基本数据类型有哪些
  
  > 当时脑子一下子宕机了。只回答了Boolean，Number，String。剩下的Object、Null、Undefined、Symobl、BigInt都没答出来
  > 
  > 参考答案: 7种(后续新增的很多都可以认为是Object)，6个基本数据类型(Boolean，Number，String，Null、Undefined、Symobl)，1个复杂数据类型(Object)，新增的复杂数据类型(BigInt)

- 面试官提问：JS如何判数据是什么类型
  
  > 回答：typeof，instanceof，Object.toString.call()
  > 
  > 参考答案: typeof，instanceof，constructor，Object.prototype.toStirng.call()

- 面试官提问：JS的Array常用有哪些方法
  
  > 回答：map、every、some、foreach
  > 
  > 参考答案: 《JavaScript高级程序设计》P138，不同使用场景都有多个方法

- 面试官提问：JS的String有哪些方法
  
  > 回答：substring，find
  > 
  > 参考答案: 《JavaScript高级程序设计》P117，不同使用场景都有多个方法

- 面试官提问：React的state和props的区别
  
  > 回答：侧重点是state和props都是组件的状态，共同的特点是变动会导致渲染触发。区别是props由父组件传入，而state是组件内的状态。

- 面试官提问：组件内会把什么数据设置为state
  
  > 回答：具有计算属性要求和UI联动的数据，设置为state。

- 面试官提问：React常用Hooks有哪些
  
  > 回答：useState、useReducer、useContext、useCallback、useMemo。并介绍了useState、useReducer主要使用场景是数据管理，useContext用于公共数据传递，useCallback缓存函数定义，useMemo缓存变量

- 面试官提问：React的useMemo是否使用过
  
  > 回答：使用过，用于缓存随着参数有固定返回的变量。

- 面试官提问：React虚拟DOM了解吗
  
  > 回答：回答了虚拟DOM的基本作用(很含糊不清)，然后介绍了React16之后的Fiber架构的工作特点是调度渲染

- 面试官提问：React的生命周期了解吗
  
  > 回答：基本的生命周期阶段有mounting、updating、unmounting，每个阶段有多个生命周期函数。大概介绍了6个函数，但是函数具体的作用和返回(很含糊不清)。

- 面试官提问：React的第三方库是否使用过
  
  > 回答：redux，介绍了基本的用法，定义store，设置action，触发dispatch，订阅变化subscribe。比较了vuex和redux的区别(很含糊不清)

- 面试官提问：React的路由拦截如何处理的
  
  > 回答：不知道咋回答，直接说使用了react-router的默认配置(水到家了)

- 面试官提问：项目中，React的打包工具使用的是什么
  
  > 回答：webpack

- 面试官提问：项目中，Webpack使用了哪些配置
  
  > 回答：不知道咋回答，直接说使用了webpack的默认配置(水到家了) 

- 面试官提问：Docker Nginx常用参数
  
  > 回答：worker_processes、worker_connection、rewrite (worker_processes、worker_connection单词还拼错了)

- 面试官了解我是否可以长期呆在杭州
  
  > 回答：是的(期间多嘴了两句base地，结果面试官不懂这个，多嘴是个减分项)

- 面试官了解我是否可以到场的时候
  
  > 回答：节后可到岗

- 面试官说需要领导与我二次面试，大概27号
  
  > 回答：(具体并未确定时间，等通知)

- 面试官反问我有什么需要确认的
  
  > 回答：确认工作地点在哪儿

### 面试总结

- 现象
1. JS基础回答基本都不完成，而且还有错误
2. React基础的回答都回答了，但是没有回答的足够清晰，部分知识点也没说清作用。
3. 第三方库和webpack只能糊弄说是使用了默认设置。
- 评价
1. JS基础不好，React基础不深，第三方库和webpack的工程知识几乎没有回答。
2. 面试官问的是比较浅的一层，等我说完后没有进行深层次的提问。所以让我混了过去。但是实际很多知识点再深入一层我就露馅了。
- 总结
1. 基础不牢固
2. 面试没有足够的亮点
3. 准备期间，不进行容易深入但是没有收益的活动，容易分散注意力，丢失状态。比如刷短视频，看小说。
4. 以面试题为导向进行知识点的扫盲，React基础知识试过这样很有效，虽然会累一点。
5. 既然是学习就需要端正态度，不论是阅读还是练习以及笔记，使用专业的工具，大脑在这种状态下能更有效有效激活神经元，提高学习效率。
6. 时刻警示自己，如果明天就要面试，那么今天的自己还差些什么
- 计划
1. 扎实JS基础
2. 深入React基础以及实际工程运用
3. 扩展第三方库比如React-Router、Redux的实际工程运用
4. Webpack工具的实际工程运用
5. 项目的面试题分析和总结
6. 算法计划

## 面试总结-0925-招行外包-杭州-二轮

### 面试前准备

#### 面经参考

- 杭州招行研发中心面经
  
  - 应届两面，一面->电面->基础，二面->现场多面试官(多位技术官 + HR)->主项目内容(运用技术、项目难点)、简历内容(读书体会)
  - 二面内容
    1. 职业规划
    2. 期望薪资
    3. 对银行项目感兴趣吗

- [2年前端暑期面试打怪升级（收获多份offer）(掘金)](https://juejin.cn/post/6876327630212169735)
  
  > 大佬前端面经, 参考这份文档整理高频题。

#### 面试计划

##### 高频题(技术)[21:30 - 23:30] - 延期[23:30 - 00:30]

###### 对象创建过程

1. 工厂模式
   工厂模式，按照特定接口标准创建返回对象。
- 优点
  
  - 工厂模式，解决创建多个类似对象的问题。

- 缺点
  
  - 对象标识问题。创建返回的对象没有具体的类型。

- 示例
  
  ```javascript
  function createPerson(name, age, job) {
    let o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function() {
        console.log(this.name);
    };
    return o; 
  }
  let person1 = createPerson("Nicholas", 29, "Software Engineer");
  ```
2. 构造函数模式
   构造函数是用于创建特定类型对象的。通常有两种方式来使用构造函数。1. Array、Object等复杂数据类型是原生的构造函数可以直接运行。2. 自定义构造函数。以函数的形式自定义方法和属性。创建实例时使用new关键字。
- 构造函数模式和工厂模式区别
  
  - 没有显式地创建对象。
  - 属性和方法直接赋值给了 this。
  - 没有 return。
  - 按照惯例，构造函数名称的首字母都是要大写的。

- 优点
  
  - 解决了工厂函数创建对象没有类型的问题。

- 缺点
  
  - 构造函数的主要问题在于，其定义的方法会在每个实例上 都创建一遍。
    
    > 以这种方式创建函数会带来不同的作用域链和标识符解析。但创建新 Function 实例的机制是一样的。因此不同实例上的函数虽然同名却不相等。因为都是做一样的事，所以没必要定义两个不同的 Function 实例。比如会出现如下情况 console.log(person1.sayName == person2.sayName); // false。

- 示例
  
  ```javascript
  function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function() {
        console.log(this.name);
    }; 
  }
  ```
```
// 构造函数不一定要写成函数声明的形式。赋值给变量的函数表达式也可以表示构造函数。
// const Person = function Person(name, age, job){
//     this.name = name;
//     this.age = age;
//     this.job = job;
//     this.sayName = function() {
//         console.log(this.name);
//     }; 
// }

let person1 = new Person("Nicholas", 29, "Software Engineer");
let person2 = new Person("Greg", 27, "Doctor");
person1.sayName(); // Nicholas 10 person2.sayName(); // Greg

```
3. 原型模式
> 使用原型对象，在它上面定义的属性和方法可以被对象实例共享。
```javascript
function Person() {}

// 设置原型对象
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function() {
    console.log(this.name);
};

// 创建实例测试
let person1 = new Person();
person1.sayName(); // "Nicholas"
let person2 = new Person();
person2.sayName(); // "Nicholas"
console.log(person1.sayName == person2.sayName); // true
```

###### 原型, 原型链

1. 原型
- 原型对象是什么
  原型对象是一个普通的对象，它包含可供其他对象共享和继承的属性和方法。只要创建一个函数，就会按照特定的规则为这个函数创建一个 prototype 属性(指向 原型对象)。
  
  > 创建一个构造函数时，JavaScript 会为该构造函数自动创建一个原型对象。
2. 理解原型行为
- 原型行为描述
  
  > -- 《JavaScript高级程序设计(第4版)》P225
  > 
  > ```text
  > 
  > ```

- 无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个 prototype 属性(指向 原型对象)

- 默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数。
  
  ```
  
  ```

- 原型行为分析
  
  ```text
  
  ```

- 构造函数

- 原型对象

- 构造函数.prototype

- 原型对象.constructor

- 构造函数.prototype == 原型对象

- 原型对象.constructor == 构造函数

- 构造函数.prototype.constructor == 构造函数
  
  > 原型对象.constructor和构造函数实现了循环引用的关系
  > 
  > ```
  > 
  > ```

- 原型行为扩展
  
  ```text
  
  ```

- 在自定义构造函数时，原型对象默认只会获得 constructor 属性，其他的所有方法都继承自 Object。

- 每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构造函数的原型对象。

- 脚本中没有访问这个[[Prototype]]特性的标准方式，但 Firefox、Safari 和 Chrome 会在每个对象上暴露__proto__属性，通过这个属性可以访问对象的原型。
  
  ```
  
  ```

- 原型行为扩展分析
  
  ```text
  
  ```

- 对象实例.prototype.__proto__ == 对象的原型对象 

- 实例与构造函数没有直接联系，与原型对象有直接联系。

- 同一个构造函数创建的两个实例，共享同一个原型对象。

- 正常的原型链都会终止于 Object 的原型对象，Object 原型的原型是 null。
  
  ```
  
  ```
3. 原型链
   原型链（prototype chain）是 JavaScript 中的一种机制，用于实现对象之间的属性和方法继承。依赖于原型层级这个行为。
- 原型层级
  在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个 实例上发现了给定的名称，则返回该名称对应的值。如果没有找到这个属性，则搜索会沿着指针进入原 型对象，然后在原型对象上找到属性后，再返回对应的值。
4. 每个 Object 实例都有如下属性和方法
   
   ```text
   --《JavaScript高级程序设计(第4版)》P56
   ```

constructor: 用于创建当前对象的函数。在前面的例子中，这个属性的值就是 Object()函数。

hasOwnProperty(propertyName): 用于判断当前对象实例(不是原型)上是否存在给定的属性。要检查的属性名必须是字符串(如 o.hasOwnProperty("name"))或符号。

isPrototypeOf(object): 用于判断当前对象是否为另一个对象的原型。(第 8 章将详细介绍原型。)

propertyIsEnumerable(propertyName): 用于判断给定的属性是否可以使用(本章稍后讨论的)for-in 语句枚举。与 hasOwnProperty()一样，属性名必须是字符串。

toLocaleString(): 返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。

toString(): 返回对象的字符串表示。

valueOf(): 返回对象对应的字符串、数值或布尔值表示。通常与 toString()的返回值相同。 因为在 ECMAScript 中 Object 是所有对象的基类，所以任何对象都有这些属性和方法。第 8 章将介绍对象间的继承机制。


###### 继承的实现
- 原型链
- 盗用构造函数
- 组合继承
- 原型式继承
> Object.create()
- 寄生式继承
- 寄生组合式继承
> 寄生式组合继承可以算是引用类型继承的最佳模式。
###### class特性
ECMAScript 6 新引入的 class 关键字具有正式定义类的能力。类(class)是 ECMAScript 中新的基础性语法糖结构。用于解决冗长的继承问题。
- 类定义

```javascript
// 类声明
class Person {}

// 类表达式
const Person = class {};
```

- 类的构成
  类可以包含构造函数方法、实例方法、获取函数、设置函数和静态类方法，但这些都不是必需的。空的类定义照样有效。默认情况下，类定义中的代码都在严格模式下执行。
  
  ```javascript
  // 空类定义，有效 
  class Foo {}
  // 有构造函数的类，有效 
  class Bar {
    constructor() {}
  }
  // 有获取函数的类，有效 
  class Baz {
  get myBaz() {}
  }
  // 有静态方法的类，有效 
  class Qux {
  static myQux() {}
  }
  ```

- 类继承
  
  ```
  ES6 类支持单继承。使用 extends 关键字，就可以继承任何拥有[[Construct]]和原型的对象。
  ```
  
  ###### 数据类型
  
  ###### var、const、let 对比
  
  ###### es next 最新规范
  
  ###### new 的过程
  
  ```text
1. 在内存中创建一个新对象。

2. 这个新对象内部的[[Prototype]]特性被赋值为构造函数的 prototype 属性。

3. 构造函数内部的 this 被赋值为这个新对象(即 this 指向新对象)。

4. 执行构造函数内部的代码(给新对象添加属性)。

5. 如果构造函数返回非空对象，则返回该对象;否则，返回刚创建的新对象。
   
   ```
   ###### this 指向问题
   ###### bind 实现方式
   ###### 闭包
   在 JavaScript 中，闭包（closure）是指函数可以访问并操作其词法作用域外的变量的能力。简单来说，闭包是由函数和其相关的引用环境组合而成的包裹体。
   ```

具体来说，闭包在以下情况下发生：

当一个函数内部定义了另一个函数，并且内部函数引用了外部函数的变量时。
内部函数被返回到外部，并且在外部调用时仍然可以访问到它的词法作用域和变量。
闭包使得函数可以保持对其词法环境（包括变量、函数等）的引用，即使在其原始定义上下文之外也能访问和操作这些引用。

闭包常常用于以下情况：

封装私有数据：通过闭包，可以创建模块化的代码，将一些变量和函数保护起来，只暴露需要的接口。
保存状态：闭包可以用于创建具有记忆性的函数，每次调用函数时都可以保留上一次调用的状态。
延迟执行：通过闭包，可以创建函数延迟执行，以便稍后调用或在异步环境中使用。

```javascript
function outerFunction() {
  var outerVariable = 'Hello';

  function innerFunction() {
    console.log(outerVariable);
  }

  return innerFunction;
}

var closure = outerFunction();
closure(); // 输出: "Hello"
```

###### 事件循环 【超高频】

> - [JavaScript Guidebook(github)](https://tsejx.github.io/javascript-guidebook/core-modules/executable-code-and-execution-contexts/concurrency-model/event-loop/)
> 
> 优质博客

- 概念
  为了协调事件、用户交互、脚本、UI 渲染、网络请求，用户代理必须使用 事件循环机制（Event Loop）。

- 类型说明
  JavaScript 的宿主环境有Node和浏览器，所以有两种事件循环机制。

- 运行机制概述
  
  > 主线程运行时候，产生堆（Heap）和栈（Stack），栈中的代码调用各种外部 API，它们在任务队列中加入各种事件。只要栈中的代码执行完毕，主线程就会通过事件循环机制读取任务队列，依次执行那些事件所对应的回调函数。
1. 所有同步任务都在主线程上执行，形成一个 执行栈（Execution Context Stack）
2. 主线程之外，还存在一个 任务队列（Task Queue）。只要异步任务有了运行结果，就在 任务队列 之中放置一个事件
   一旦 执行栈 中的所有同步任务执行完毕，系统就会读取 任务队列，看看里面有哪些待执行事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行
3. 主线程不断重复上面的第三步
- 浏览器环境
  
  1. 事件分类
     
     > 宏任务与微任务的区别在于队列中事件的执行优先级。进入整体代码（宏任务）后，开始首次事件循环，当执行上下文栈清空后，事件循环机制会优先检测微任务队列中的事件并推至主线程执行，当微任务队列清空后，才会去检测宏任务队列中的事件，再将事件推至主线程中执行，而当执行上下文栈再次清空后，事件循环机制又会检测微任务队列，如此反复循环。
  - 宏任务(MacroTask)：main script、setTimeout、setInterval、setImmediate（Node.js）、I/O（Mouse Events、Keyboard Events、Network Events）、UI Rendering（HTML Parsing）、MessageChannel
  
  - 微任务(MicroTask)：Promise.then（非 new Promise）、process.nextTick（Node.js）、MutationObserver
    
    ###### 类型判断
    
    ###### 手写 Promise

###### 输入 URL 到页面展示 【超高频】

###### 跨域 【超高频】

###### HTTP 各版本 （通常是由缓存带出来的问题）【高频】

###### HTTPS 原理 【高频】

###### TCP 三次握手、四次挥手

###### TCP 和 UDP 区别

###### HTTP 常见状态码

###### 鉴权

##### 项目题(技术)[23:30 - 01:00] - 延期[00:30 - 01:30]

###### 项目问答模版

1. 项目的背景是什么；

2. 当前项目的目的是什么；

3. 在开发过程中，你的角色是什么；

4. 在开发过程中有遇到过什么样的难题；

5. 遇到这些问题，你都是如何进行解决的；

6. 项目完成之后，取得了哪些成果；

7. 项目具体问题解决方案
   
   > 额外增加，做好预案
   
   ###### 安徽农村信用社联合社金农易贷管理系统

8. 项目的背景是什么；

9. 当前项目的目的是什么；

10. 在开发过程中，你的角色是什么；

11. 在开发过程中有遇到过什么样的难题；

12. 遇到这些问题，你都是如何进行解决的；

13. 项目完成之后，取得了哪些成果；

14. 项目具体问题解决方案
- useEffect自定义React Hooks来解决页面刷新(缓存数据加载)
  
  > 解决页面刷新次数登记的问题，自定义Hook，通过localStorage来取出缓存的数据，比如刷新次数。

- useEffect自定义React Hooks来处理异步请求处理
  
  > axios封装网络请求，然后自定义Hook，通过useEffect再封装一层支持参数的传输和redux控制loading的加载以及处理error的抛出。

- 函数式组件的封装技巧
  
  > from chatgpt
  >   使用 Props：合理使用组件的 props，将组件的行为和外部数据进行解耦。通过传递不同的 props 值，使组件能够适应各种情况下的展示和功能需求。
  
    使用默认值和类型检查：为组件的 props 设置默认值，以防止因缺少某些 props 而导致的错误。同时，可以使用 PropTypes 或 TypeScript 等工具对组件的 props 进行类型检查，确保正确使用和传递 props。
  
  > class components: propTypes进行类型检查，defaultProps设置默认值
  > 
  > function components: 而函数式组件只能通过显式的判断和默认值给予。
  >   提取可复用的逻辑：如果存在可复用的逻辑或功能，可以将其提取为自定义的 Hooks 或辅助函数，以便在多个组件中共享和重复使用。
  
    使用组合和高阶组件：利用组合和高阶组件的概念，可以将多个小型组件组合起来形成更大的组件，实现组件的复用和灵活性。
  
    单一职责原则：确保每个组件只关注单一的职责或功能。通过将组件拆分为更小的组件，可以提高组件的可维护性和复用性，并使代码更易于理解和测试。
  
    避免状态共享：尽量避免在多个组件之间共享状态。如果需要共享状态，可以考虑使用状态管理库（如 Redux、MobX）来管理该状态，而不是将其存储在组件层级中。
  
    使用 Render Props 或 Hooks：使用 Render Props 或自定义 Hooks，可以将组件的复用逻辑以可配置的方式传递给其他组件，从而实现更高级的组件封装和代码重用。
  
    模块化组织：根据项目的需求和结构，合理地组织和划分组件，使得整个代码库具有清晰的结构，易于维护和扩展。
  
    总的来说，函数式组件的封装技巧包括合理使用 props、提取可复用的逻辑、使用组合和高阶组件、遵循单一职责原则等。这些技巧能够帮助改善代码的可读性、可维护性和可重用性，提高开发效率。

- 如何进行路由拦截处理

- 使用了哪些第三方库

- Webpack配置使用了什么

- 做了什么性能优化

- 做了什么安全处理
  
  ###### 邮惠万家银行2022年新增功能工程(三期)
1. 项目的背景是什么；

2. 当前项目的目的是什么；

3. 在开发过程中，你的角色是什么；

4. 在开发过程中有遇到过什么样的难题；

5. 遇到这些问题，你都是如何进行解决的；

6. 项目完成之后，取得了哪些成果；

7. 项目具体问题解决方案
   
   ###### 海外国际菲律宾CIMB互联网产品前端数据迁移项目

8. 项目的背景是什么；

9. 当前项目的目的是什么；

10. 在开发过程中，你的角色是什么；

11. 在开发过程中有遇到过什么样的难题；

12. 遇到这些问题，你都是如何进行解决的；

13. 项目完成之后，取得了哪些成果；

14. 项目具体问题解决方案
    
    ###### Sinarmas手机银行-群组账户专项

15. 项目的背景是什么；

16. 当前项目的目的是什么；

17. 在开发过程中，你的角色是什么；

18. 在开发过程中有遇到过什么样的难题；

19. 遇到这些问题，你都是如何进行解决的；

20. 项目完成之后，取得了哪些成果；

21. 项目具体问题解决方案
- TinyBuilder
  
  > - [跨平台布局引擎Yoga的学习和使用(博客)](https://juejin.cn/post/6844903591233191943)

- 小程序
  
  > - [前端面试题之——小程序篇(博客)](https://www.rstk.cn/news/614260.html?action=onClick)

- Less和Sass
  
  > - [【查缺补漏】css、Less、Sass定义变量，混合，嵌套，运算等（内含10道面试题）(博客)](https://blog.csdn.net/qq_37210523/article/details/110412583)

##### 高频题(HR)[01:00 - 02:00]

1. 最近在看什么书籍，《JavaScript高级程序设计(第四版本)》第8章对象、《Head First设计模式》 弗里曼等人著作。

2. 常用设计模式
   
   - 单例模式
   - 工厂模式
   - 装饰器模式
   - 适配器模式
   - 命令模式

3. 安全问题
   
   - 同源策略
     
     > 安全机制，协议、域名、端口全部相等的情况下认为是同源请求。允许对cookie、localStorge等数据进行读取。如果是非同源请求，则不允许读取，但是允许执行写入和嵌入操作。
     
     - 避免同源策略
       
       1. CORS(跨域资源共享)
          
          > 通过Acces-Origin-Allow- 前缀的header，设置是否允许跨域资源共享，并且设置允许的域名以及方法。
       
       2. Nginx代理
          
          > 1. 在nginx上设置Acces-Origin-Allow- 前缀的header，并转发到服务端。2. 直接解析url，转发请求
   
   - XSS攻击
     
     > 脚本嵌入到url进行攻击
     
     - 解决方案
     1. 禁止执行不可信数据，代码安全性校验
   
   - CORF跨站请求攻击
     
     > 外链点击，默认携带目标网站的Cookie发送跨域请求。
     
     - 解决方案
     1. 禁止跨域请求，检查请求头里的来源域名
        - Origin Header
        - Referrer Header

### 面试前两个小时状态

### 面试现场

### 面试总结

## 新一轮面试突击计划

### CSS3

### HTML5

### ES6特性

### JavaScript基础

### React基础